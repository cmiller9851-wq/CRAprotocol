"""Merkle tree utilities for the CRA protocol.

Existing functionality (tree building, verification) is kept unchanged.
The new `generate_proof` method enables cross‑jurisdiction audits by
producing a Merkle proof for any leaf index.
"""

import hashlib
from typing import List, Tuple


class MerkleTree:
    def __init__(self, leaves: List[bytes]):
        self.leaves = leaves
        self.levels = self._build_tree(leaves)

    @staticmethod
    def _hash(data: bytes) -> bytes:
        return hashlib.sha256(data).digest()

    def _build_tree(self, leaves: List[bytes]) -> List[List[bytes]]:
        """Build the tree bottom‑up and store each level."""
        current = [self._hash(l) for l in leaves]
        levels = [current]
        while len(current) > 1:
            nxt = []
            for i in range(0, len(current), 2):
                left = current[i]
                right = current[i + 1] if i + 1 < len(current) else left
                nxt.append(self._hash(left + right))
            levels.append(nxt)
            current = nxt
        return levels

    def root(self) -> bytes:
        """Return the Merkle root."""
        return self.levels[-1][0] if self.levels else b""

    def verify_proof(self, leaf: bytes, proof: List[Tuple[bytes, bool]], root: bytes) -> bool:
        """Verify a proof generated by `generate_proof`."""
        computed = self._hash(leaf)
        for sibling_hash, is_left in proof:
            if is_left:
                computed = self._hash(sibling_hash + computed)
            else:
                computed = self._hash(computed + sibling_hash)
        return computed == root

    # --------------------------------------------------------------
    # NEW: Merkle‑proof generation
    # --------------------------------------------------------------
    def generate_proof(self, leaf_index: int) -> List[Tuple[bytes, bool]]:
        """
        Return a Merkle proof for the leaf at *leaf_index*.

        The proof is a list of (sibling_hash, is_left) tuples that can be
        verified with :meth:`verify_proof`.  This method is required for
        cross‑jurisdiction audits where a verifier only has a subset of the
        log.
        """
        if leaf_index < 0 or leaf_index >= len(self.leaves):
            raise IndexError("leaf_index out of range")

        proof: List[Tuple[bytes, bool]] = []
        idx = leaf_index
        for level in self.levels[:-1]:  # skip the root level
            sibling_idx = idx ^ 1  # toggle last bit to get sibling
            is_left = sibling_idx < idx
            sibling_hash = level[sibling_idx] if sibling_idx < len(level) else level[idx]
            proof.append((sibling_hash, is_left))
            idx //= 2  # move up one level
        return proof

    # --------------------------------------------------------------
    # Helper for loading a persisted tree (used by examples)
    # --------------------------------------------------------------
    @classmethod
    def load(cls, model_id: str) -> "MerkleTree":
        """
        Load a persisted Merkle tree for *model_id*.
        Placeholder implementation – replace with actual storage logic.
        """
        # For demonstration we rebuild from a dummy list.
        dummy_leaves = [f"{model_id}_log_{i}".encode() for i in range(10)]
        return cls(dummy_leaves)
